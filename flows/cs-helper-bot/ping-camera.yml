id: ping-camera
namespace: visio.cs-helper-bot
description: Reimplementação da função ping_camera do JoIA bot

labels:
  owner: caio.sampaio

inputs:
  - id: shop_id 
    type: STRING
    required: true
    description: Identificação do estabelecimento
  - id: camera_id
    type: STRING
    required: true
    description: Identificação da câmera

tasks:
  - id: get_kvs
    type: io.kestra.plugin.core.output.OutputValues
    values:
      VISIO_URL: "{{kv(namespace='visio.system', key='visio_url')}}"  
           
  - id: retrieve_camera
    type: io.kestra.plugin.core.flow.Sequential
    tasks:

    - id: authenticate
      type: io.kestra.plugin.core.http.Request
      uri: "{{outputs.get_kvs.values['VISIO_URL']}}/api/auth/login"
      method: POST
      contentType: application/json
      body: '{{ {"user": secret("VISIO_USER"), "pwd": secret("VISIO_PASSWORD")} | json }}'

    - id: extract-token
      type: io.kestra.plugin.transform.jsonata.TransformValue
      maxDepth: 1
      from: "{{outputs.authenticate.body}}"
      expression: token
      
    - id: get_camera 
      type: io.kestra.plugin.core.http.Request
      uri: "{{outputs.get_kvs.values['VISIO_URL']}}/api/camera/{{inputs.shop_id}}/{{inputs.camera_id}}"
      method: GET
      headers:
        # Criando uma string explicitamente concatenando 'Bearer' e o token
        Authorization: '{{ "Bearer " ~ outputs["extract-token"].value }}'
        
  - id: get_all_statuses
    type: io.kestra.plugin.core.flow.Parallel
    tasks:
    - id: get_addr_status
      type: io.kestra.plugin.scripts.python.Script
      taskRunner:
        type: io.kestra.plugin.scripts.runner.docker.Docker
      script: |
        import json
        import subprocess
        from kestra import Kestra

        camera = json.loads('{{ outputs.get_camera.body }}')
        camera = camera[0] # Câmera é o primeiro item da lista

        result = subprocess.run(
          ['ping', '-c', '1', camera["address"], '-w', '2'])
        Kestra.outputs({
          "ping_success": result.returncode == 0
        })  

    - id: retrieve_image_status
      type: io.kestra.plugin.core.flow.Sequential
      tasks:
      - id: get_stream_url
        type: io.kestra.plugin.scripts.python.Script
        taskRunner:
          type: io.kestra.plugin.scripts.runner.docker.Docker
        script: |
          import json
          from kestra import Kestra

          camera = json.loads('{{ outputs.get_camera.body }}')[0]
          #camera = camera[0] # Câmera é o primeiro item da lista

          # Build rtsp url 
          model = camera["model"]
          user = camera["camera_user"]
          password = camera["camera_password"]
          address = camera["address"]
          port = camera["port"]

          stream = ''
          if model.upper() == '4020':
            stream = f"rtsp://{user}:{password}@"
            stream += f"{address}:{port}"
            stream += f"/cam/realmonitor?channel=2&subtype=0"
          elif model.upper() == 'FISHEYE':
            stream = f"rtsp://{user}:{password}"
            stream += f"@{address}:{port}"
            stream += "/cam/realmonitor?channel=2&subtype=0"
          elif model.upper() == '1220':
            stream = f"rtsp://{address}:{port}/"
            stream += f"user={user}&password={password}"
            stream += "&channel=2&stream=0.sdp"
          elif model.upper() in ['IPC-C22C', 'IPC-K42', 'DS-2CD3935FWD-IWS']:
              stream = f"rtsp://{user}:{password}"
              stream += f"@{address}:{port}"
              stream += "/cam/realmonitor?channel=2&subtype=0"
          elif model.upper() == 'DS-2CD2125FWD-I' or model.upper() == 'DS-2CD2020F-I':
            stream = f"rtsp://{user}:{password}@"
            stream += f"{address}:{port}"
            stream += f"/Streaming/Channels/102"
          # else:
          #     raise (ValueError(f"Incorrect camera model {model}"))
          Kestra.outputs({
            'stream':stream
          })

      - id: get_image_status
        type: io.kestra.plugin.scripts.shell.Commands
        taskRunner:
          type: io.kestra.plugin.scripts.runner.docker.Docker
        containerImage: jrottenberg/ffmpeg
        commands:      
          - |
            #-timeout 60
            set +e 
            ffmpeg -loglevel error -rtsp_transport tcp -i "{{ outputs.get_stream_url.vars.stream }}" -frames:v 1 -f null - 2>&1
            EXIT_CODE=$?
            set -e

            IMAGE_STATUS=true
            if [ "$EXIT_CODE" -ne 0 ]; then 
              IMAGE_STATUS=false
            fi
            echo "::{\"outputs\":{\"image_status\":$IMAGE_STATUS}}::"
    
    - id: retrieve_repo_status
      type: io.kestra.plugin.core.flow.Sequential
      tasks:
        - id: get_buckets
          type: io.kestra.plugin.scripts.python.Script
          taskRunner:
            type: io.kestra.plugin.scripts.runner.docker.Docker
          script: |
            import json
            from kestra import Kestra

            camera = json.loads('{{ outputs.get_camera.body }}')
            camera = camera[0] # Câmera é o primeiro item da lista

            repo_reference = camera["bucket_url"]
            camera_type = camera["tipo"] or 'checkout'

            buckets_to_check = [repo_reference]
            if camera_type in ["checkout", "pista"]:
              # if '-media' in repo_reference:
              #   bucket_logic = repo_reference.replace('-media', '-logic')  
              # else:
              #   bucket_logic = repo_reference.replace('-gravacao', '-processamento')
              bucket_logic = repo_reference.replace('-gravacao', '-processamento')
              buckets_to_check.append(bucket_logic)

            print(f'os buckets são {buckets_to_check}')
            
            Kestra.outputs({
              "buckets_to_check": buckets_to_check
            })
            
        - id: get_repo_status
          type: io.kestra.plugin.gcp.cli.GCloudCLI
          # namespaceFiles:
          #   include:
          #     - credentials/gcp_credentials.json
          ##serviceAccount: "credentials/gcp_credentials.json"
          commands:
            # - |
              # Autenticando manualmente enquanto segredos não são usados
              #gcloud auth activate-service-account --key-file=credentials/gcp_credentials.json 2>&1

            - |
              cat <<-EOF > $(pwd)/gcp_credentials.json 
              {{secret("VISIO_GCP_CREDENTIALS")}}
              EOF

              gcloud auth activate-service-account --key-file=$(pwd)/gcp_credentials.json 2>&1
            
              REPO_STATUS=true
              # A lista está no formato [bucket_a,bucket_b,bucket_c]
              # é necessário remover os colchetes e trocar as ',' por ' '
              BUCKET_LIST={{outputs.get_buckets.vars.buckets_to_check}}
              BUCKET_LIST=$(echo "$BUCKET_LIST" | tr -d '[]' | tr ',' ' ')

              for bucket in $BUCKET_LIST; do
                echo "Verificando bucket: $bucket"
                OUTPUT=$(gcloud storage buckets describe gs://$bucket 2>&1)

                if [ $? -eq 0 ]; then
                  echo "Bucket $bucket existe."
                else
                  if echo "$OUTPUT" | grep -q "does not have permission"; then
                    echo "Sem permissão para acessar o bucket $bucket."
                  elif echo "$OUTPUT" | grep -q "404"; then
                    echo "Bucket $bucket não existe."
                  else
                    echo "Erro desconhecido ao acessar o bucket $bucket: $OUTPUT"
                  fi
                  REPO_STATUS=false
                  break
                fi
              done
              # Descomentar para apurar problemas de gcloud
              #echo "Output: $OUTPUT" 2>&1
              echo "::{\"outputs\":{\"repo_status\":$REPO_STATUS}}::"

    - id: get_camera_internal_storage_status
      type: io.kestra.plugin.scripts.python.Script
      taskRunner:
        type: io.kestra.plugin.scripts.runner.docker.Docker
      containerImage: ghcr.io/kestra-io/kestrapy:latest
      beforeCommands:
        - pip install requests
      script: |
        import json
        import xml.etree.ElementTree as ET
        from requests.auth import HTTPDigestAuth
        from typing import List

        import requests
        from kestra import Kestra

        try:
            camera = json.loads('{{ outputs.get_camera.body }}')
            camera = camera[0]

            # Criação do payload XML
            root: ET.Element = ET.Element('storage')
            root.set('xmlns', 'http://www.hikvision.com/ver20/XMLSchema')
            root.set('version', '2.0')
            hdd_list = ET.SubElement(root, 'hddList')
            hdd_list.set('xmlns', 'http://www.hikvision.com/ver10/XMLSchema')
            hdd_list.set('version', '1.0')
            hdd_list.set('size', '8')
            hdd = ET.SubElement(hdd_list, 'hdd')
            hdd.set('xmlns', 'http://www.hikvision.com/ver20/XMLSchema')
            hdd.set('version', '2.0')
            hdd.text = '...'
            nas_list = ET.SubElement(root, 'nasList')
            nas_list.set('xmlns', 'http://www.hikvision.com/ver20/XMLSchema')
            nas_list.set('version', '2.0')
            support_mount_type = ET.SubElement(nas_list, 'supportMountType')
            support_mount_type.set('opt', 'NFS,SMB/CIFS')
            authentication = ET.SubElement(nas_list, 'authentication')
            authentication.set('opt', 'SMB/CIFS')
            work_mode = ET.SubElement(root, 'workMode')
            sd_card_payload = ET.tostring(root, encoding='unicode')

            camera_addr = camera.get("address")
            isapi_port = str(int(camera.get("port", 80)) + 1)
            url = f"http://{camera_addr}:{isapi_port}/ISAPI/ContentMgmt/Storage"

            camera_user = camera.get("camera_user")
            camera_password = camera.get("camera_password")

            res = requests.get(
                url,
                allow_redirects=True,
                data=sd_card_payload,
                auth=HTTPDigestAuth(username=camera_user, password=camera_password),
                stream=True,
                timeout=5
            )
            res.raise_for_status()  # Se status 4xx/5xx, levanta exceção

            xml_text = res.text
            xml_element = ET.fromstring(
                xml_text.replace('http://www.hikvision.com/ver20/XMLSchema', '')
                        .replace('http://www.hikvision.com/ver10/XMLSchema', '')
            )

            element_list: List[ET.Element] = xml_element.findall('./hddList/hdd')
            storage_status_list: List[dict] = []
            for element in element_list:
                total_mb = element.find('./capacity')
                free_mb = element.find('./freeSpace')
                hdd_type = element.find('./hddType')
                storage_name = element.find('./hddName')
                status = element.find('./status')
                permission = element.find('./property')
                storage_status_list.append({
                    "status": status.text == 'ok' if status is not None else False,
                    "total_mb": int(total_mb.text) if total_mb is not None else None,
                    "used_mb": int(total_mb.text) - int(free_mb.text)
                    if free_mb is not None and total_mb is not None else None,
                    "hdd_type": hdd_type.text if hdd_type is not None else None,
                    "storage_name": storage_name.text if storage_name is not None else None,
                    "permission": (
                        "READ_WRITE" if permission is not None and permission.text == 'RW' else
                        "READ" if permission is not None and permission.text == 'R' else
                        "WRITE" if permission is not None and permission.text == 'W' else
                        None
                    )
                })
            Kestra.outputs({"storage_status_list": storage_status_list})

        except Exception as e:
            print(f"Erro geral capturado no script: {repr(e)}")
            Kestra.outputs({"storage_status_list": []})
            
  - id: log_statuses
    type: io.kestra.plugin.core.log.Log
    message: |
      --- Status Report ---
      Shop ID: {{inputs.shop_id}}
      Camera ID: {{inputs.camera_id}}
      Ping Success (get_addr_status): {{ outputs['get_addr_status'].vars.ping_success }}
      Image Status (get_image_status): {{ outputs['get_image_status'].vars.image_status }}
      Repo Status (get_repo_status): {{ outputs['get_repo_status'].vars.repo_status }}
      Internal Storage Status (get_camera_internal_storage_status): {{ outputs['get_camera_internal_storage_status'].vars.storage_status_list }}
      ---------------------

outputs:
  - id: statuses
    type: JSON
    value: >
      {
        "addr_status": "{{ outputs['get_addr_status'].vars.ping_success }}",
        "image_status": "{{ outputs['get_image_status'].vars.image_status }}",
        "repo_status": "{{ outputs['get_repo_status'].vars.repo_status }}",
        "internal_storage_status": {{ outputs['get_camera_internal_storage_status'].vars.storage_status_list }}
      }
    description: "status report"